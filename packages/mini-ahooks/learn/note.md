# 包管理器
npm：
> Npm 是世界上最大的软件注册中心。来自各大洲的开源开发人员使用 npm 来共享和借用包，许多组织也使用 npm 来管理私有开发
cnpm：
> npmmirror 中国镜像站。这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。
pnpm：
> - 速度快、节省磁盘空间的软件包管理器
> - 快速。pnpm 是同类工具速度的将近 2 倍。
> - 高效。node_modules 中的所有文件均链接自单一存储位置。
> - 支持单体仓库。pnpm 内置了对单个源码仓库中包含多个软件包的支持。
> - 权限严格。pnpm 创建的 node_modules 默认并非扁平结构，因此代码无法对任意软件包进行访问。

yarn：
> Yarn 是一个软件包管理器，还可以作为项目管理工具。无论你是小型项目还是大型单体仓库（monorepos），无论是业余爱好者还是企业用户，Yarn 都能满足你的需求。

pnpm和yarn支持monorepos。
# package.json
## peerDependencies
插件正确运行的前提是，
- 核心依赖库必须先下载安装，不能脱离核心依赖库而被单独依赖并引用；
- 插件入口api 的设计必须要符合核心依赖库的规范；
- 插件的核心逻辑运行在依赖库的调用中；
- 在项目实践中，同一插件体系下，核心依赖库版本最好是相同的；

插件使用 dependencies 声明依赖库的特点：
如果用户显式依赖了核心库，则可以忽略各插件的 peerDependency 声明；
如果用户没有显式依赖核心库，则按照插件 peerDependencies 中声明的版本将库安装到项目根目录中；
当用户依赖的版本、各插件依赖的版本之间不相互兼容，会报错让用户自行修复；
# jest
> Jest 是一个 JavaScript 测试框架，旨在确保任何 JavaScript 代码的正确性。它为你提供了。它为你提供了 易于理解、熟悉且功能丰富的 API 来编写测试用例，并快速地反馈结果。

# monorepo
## git submodule
`git submodule`不生效。
提示：`fatal: 'mini-ahooks' already exists in the index`
## Lerna
> Lerna 是一个快速的现代构建系统，用于管理和发布来自同一存储库的多个 JavaScript/TypeScript 包。Lerna 是用于 
> TypeScript/JavaScript的原始monorepo 工具。它已经存在多年，被数以万计的项目使用，包括 React、Jest 和 Babel。

>它解决了 JavaScript monorepos 的三个最大问题：
> - Lerna 在 repo 中链接不同的项目，因此它们可以相互导入，而无需向 NPM 发布任何内容。
> - Lerna 对任意数量的项目运行命令，它以最有效的方式、以正确的顺序执行它，并且可以将其分布在多台机器上。
> - Lerna 管理您的发布过程，从版本管理到发布再到 NPM，它提供了多种选项来确保可以适应任何工作流程。
## PNPM Workspace
### Lerna + Yarn Workspaces
#### 优点
Lerna 是一个高级 monorepo 工具，它提供同时管理一个或多个应用/包的抽象。
Yarn Workspaces 是一个底层的工具，它负责处理包的安装、在项目之间创建符号链接，和在根目录和受控的项目文件夹下中分配模块。
它们之间的互补性是突出的。它们一起运行的很好
#### 问题
- Yarn Workspaces（v1）已经不再维护（上次更新是在 2018）；
- Lerna 文档是可以的（但不够详细），你需要自己弄明白很多问题；
- Lerna 发布系统并不像看上去那么简单，特别是用 commit lint 生成自动发布时。
- 你可能会不太理解你需要运行的命令是什么意思或者你不知道你在运行其它命令的时候，还有什么命令正在运行中；
- Lerna CLI 有一些像你无法在同一时间安装多个依赖 等问题。
- Lerna CLI --scope 并不可靠并且难以理解和使用；
- 有一个 wizard 在常见任务中帮助我们，但它更像是在主仓库之外维护的。
- Lerna 目前是没有维护的;
### PNPM Workspace
pnpm是一个 JavaScript 项目的包管理工具，与 npm 和 Yarn功能一样，只是更加高效。
#### 好处
pnpm最大的好处是解决了一个由npm引入，yarn复制的问题--安装依赖项的方式。
pnpm 旨在解决两大问题：
- 节约磁盘空间并提升安装速度
  当使用 npm 或 Yarn 时，如果你有 100 个项目使用了某个依赖（dependency），就会有 100 份该依赖的副本保存在硬盘上。  而在使用 pnpm 时，依赖会被存储在内容可寻址的存储中。如果使用 pnpm 安装依赖的话，它首先会将依赖下载到它自己的「仓库」（~/.pnpm-store）中。之后，**pnpm 将在你的项目中的 node_modules 中创建一个该模块的硬链接。**（指向磁盘中的某个文件）。因此我们节省了很多磁盘空间，并且如果我们的新项目使用了我们已经安装过的依赖，那么新项目安装依赖的速度会更加的快。
- 幽灵依赖的解决——创建非扁平化的 node_modules 文件夹
  使用 npm 或 Yarn Classic 安装依赖项时，所有包都被提升到模块目录的根目录。 因此，项目可以访问到未被添加进当前项目的依赖。、用 npm 安装依赖时，他会把所有的依赖和依赖中的所有东西都打包到 node_modules 文件夹下。这种方式就是所谓的“扁平化方式”。虽然这种方式已经工作了许多年，但是这种方式会导致一些问题，我们称这种问题叫做：“幽灵依赖”。
  因为上述这种情况是可能发生的，所以我们声明的依赖以及依赖的依赖也可能出现这种问题，即在没有声明某个依赖作为依赖或对等依赖（peerDependency）的前提下，从 node_modules 中引入了这个依赖。
  pnpm 会将每个依赖项安装在 .pnpm 的对应目录（包名+版本）中，然后将你已经在项目的 package.json 中明确定义的那些依赖“移动”（译者注：实际上是创建一个符号链接指向 .pnpm 中的对应模块）到项目的 node_modules 中。
  虽然用这种方式安装 node_modules 更加可靠，但这可能破坏 pnpm 与那些基于扁平化 node_modules 结构构建的应用的兼容性。幸运的是，pnpm 考虑了这些问题，并且提供了个叫 `**shamefully-hoist **`的标记来解决这些问题。当我们用这个标记时，项目依赖会依照“扁平化的方式”被安装，这使得诸如 Strapi 这样的应用能够正常工作。
### 软硬链接
#### 硬链接
```linux
ln [options] existingfile newfile  
ln[options] existingfile-list directory 
```
- 具有相同inode节点号的多个文件互为硬链接文件；
- 删除硬链接文件或者删除源文件任意之一，文件实体并未被删除；
- 只有删除了源文件和所有对应的硬链接文件，文件实体才会被删除；
- 硬链接文件是文件的另一个入口；
- 可以通过给文件设置硬链接文件来防止重要文件被误删；
- 创建硬链接命令 `ln 源文件 硬链接文件`；
- 硬链接文件是普通文件，可以用rm删除；
- 对于静态文件（没有进程正在调用），当硬链接数为0时文件就被删除。注意：如果有进程正在调用，则无法删除或者即使文件名被删除但空间不会释放。
#### 软链接
- 软链接类似windows系统的快捷方式；
- 软链接里面存放的是源文件的路径，指向源文件；
- 删除源文件，软链接依然存在，但无法访问源文件内容；
- 软链接失效时一般是白字红底闪烁；
- 创建软链接命令 `ln -s 源文件 软链接文件`；
- 软链接和源文件是不同的文件，文件类型也不同，inode号也不同；
- 软链接的文件类型是“l”，可以用rm删除。
#### 区别
- 原理上，硬链接和源文件的inode节点号相同，两者互为硬链接。软连接和源文件的inode节点号不同，进而指向的block也不同，软连接block中存放了源文件的路径名。 实际上，硬链接和源文件是同一份文件，而软连接是独立的文件，类似于快捷方式，存储着源文件的位置信息便于指向。 
- 使用限制上，不能对目录、不同文件系统、不存在的文件创建硬链接；但可以对它们创建软连接。
# 参考资料
- [npm](https://docs.npmjs.com/about-npm)
- [cnpm](https://npmmirror.com/)
- [pnpm](https://www.pnpm.cn/)
- [yarn](https://www.yarnpkg.cn/)
- [一文搞懂peerDependencies](https://juejin.cn/post/6844904134248759309)
- [jest](https://www.jestjs.cn/)
- [lerna](https://lerna.js.org/)
- [用 PNPM Workspaces 替换 Lerna + Yarn](https://juejin.cn/post/7071992448511279141)
- [软硬链接](https://xzchsia.github.io/2020/03/05/linux-hard-soft-link/)